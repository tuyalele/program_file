C51 COMPILER V9.54   PROTOCOL                                                              02/26/2021 13:53:45 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE PROTOCOL
OBJECT MODULE PLACED IN .\Objects\protocol.obj
COMPILER INVOKED BY: H:\Keil_v5\C51\BIN\C51.EXE mcu_sdk\protocol.c COMPACT RTX51 OPTIMIZE(8,SPEED) BROWSE INCDIR(.\H;.\m
                    -cu_sdk;.\UART;.\0.96OLED;.\SHT30) DEBUG OBJECTEXTEND PRINT(.\Listings\protocol.lst) TABS(2) OBJECT(.\Objects\protocol.ob
                    -j)

line level    source

   1          /**********************************Copyright (c)**********************************
   2          **                       ç‰ˆæƒæ‰€æœ‰ (C), 2015-2020, æ¶‚é¸¦ç§‘æŠ€
   3          **
   4          **                             http://www.tuya.com
   5          **
   6          *********************************************************************************/
   7          /**
   8           * @file    protocol.c
   9           * @author  æ¶‚é¸¦ç»¼åˆåè®®å¼€å‘ç»„
  10           * @version v2.5.6
  11           * @date    2020.12.16
  12           * @brief                
  13           *                       *******éå¸¸é‡è¦ï¼Œä¸€å®šè¦çœ‹å“¦ï¼ï¼ï¼********
  14           *          1. ç”¨æˆ·åœ¨æ­¤æ–‡ä»¶ä¸­å®ç°æ•°æ®ä¸‹å‘/ä¸ŠæŠ¥åŠŸèƒ½
  15           *          2. DPçš„ID/TYPEåŠæ•°æ®å¤„ç†å‡½æ•°éƒ½éœ€è¦ç”¨æˆ·æŒ‰ç…§å®é™…å®šä¹‰å®ç°
  16           *          3. å½“å¼€å§‹æŸäº›å®å®šä¹‰åéœ€è¦ç”¨æˆ·å®ç°ä»£ç çš„å‡½æ•°å†…éƒ¨æœ‰#erræç¤º,å®Œæˆå‡½æ•
             -°åè¯·åˆ é™¤è¯¥#err
  17           */
  18          
  19          /****************************** å…è´£å£°æ˜ ï¼ï¼ï¼ *******************************
  20          ç”±äºMCUç±»å‹å’Œç¼–è¯‘ç¯å¢ƒå¤šç§å¤šæ ·ï¼Œæ‰€ä»¥æ­¤ä»£ç ä»…ä¾›å‚è€ƒï¼Œç”¨æˆ·è¯·è‡ªè¡ŒæŠŠæ§æœ€ç»ˆä»£ç
             - è´¨é‡ï¼Œ
  21          æ¶‚é¸¦ä¸å¯¹MCUåŠŸèƒ½ç»“æœè´Ÿè´£ã€‚
  22          ******************************************************************************/
  23          
  24          /******************************************************************************
  25                                          ç§»æ¤é¡»çŸ¥:
  26          1:MCUå¿…é¡»åœ¨whileä¸­ç›´æ¥è°ƒç”¨mcu_api.cå†…çš„wifi_uart_service()å‡½æ•°
  27          2:ç¨‹åºæ­£å¸¸åˆå§‹åŒ–å®Œæˆå,å»ºè®®ä¸è¿›è¡Œå…³ä¸²å£ä¸­æ–­,å¦‚å¿…é¡»å…³ä¸­æ–­,å…³ä¸­æ–­æ—¶é—´å¿…é¡»çŸ
             -­,å…³ä¸­æ–­ä¼šå¼•èµ·ä¸²å£æ•°æ®åŒ…ä¸¢å¤±
  28          3:è¯·å‹¿åœ¨ä¸­æ–­/å®šæ—¶å™¨ä¸­æ–­å†…è°ƒç”¨ä¸ŠæŠ¥å‡½æ•°
  29          ******************************************************************************/
  30          
  31          #include "wifi.h"
  32          #include  "main.h"
  33          #include  "UART1-2.H"
  34          
  35          
  36          #ifdef WEATHER_ENABLE
              /**
               * @var    weather_choose
               * @brief  å¤©æ°”æ•°æ®å‚æ•°é€‰æ‹©æ•°ç»„
               * @note   ç”¨æˆ·å¯ä»¥è‡ªå®šä¹‰éœ€è¦çš„å‚æ•°ï¼Œæ³¨é‡Šæˆ–è€…å–æ¶ˆæ³¨é‡Šå³å¯ï¼Œæ³¨æ„æ›´æ”¹
               */
              const char *weather_choose[WEATHER_CHOOSE_CNT] = {
                  "temp",
                  "humidity",
                  "condition",
                  "pm25",
                  /*"pressure",
                  "realFeel",
                  "uvi",
                  "tips",
C51 COMPILER V9.54   PROTOCOL                                                              02/26/2021 13:53:45 PAGE 2   

                  "windDir",
                  "windLevel",
                  "windSpeed",
                  "sunRise",
                  "sunSet",
                  "aqi",
                  "so2 ",
                  "rank",
                  "pm10",
                  "o3",
                  "no2",
                  "co",
                  "conditionNum",*/
              };
              #endif
  66          
  67          
  68          /******************************************************************************
  69                                        ç¬¬ä¸€æ­¥:åˆå§‹åŒ–
  70          1:åœ¨éœ€è¦ä½¿ç”¨åˆ°wifiç›¸å…³æ–‡ä»¶çš„æ–‡ä»¶ä¸­include "wifi.h"
  71          2:åœ¨MCUåˆå§‹åŒ–ä¸­è°ƒç”¨mcu_api.cæ–‡ä»¶ä¸­çš„wifi_protocol_init()å‡½æ•°
  72          3:å°†MCUä¸²å£å•å­—èŠ‚å‘é€å‡½æ•°å¡«å…¥protocol.cæ–‡ä»¶ä¸­uart_transmit_outputå‡½æ•°å†…,å¹¶åˆ é™¤#error
  73          4:åœ¨MCUä¸²å£æ¥æ”¶å‡½æ•°ä¸­è°ƒç”¨mcu_api.cæ–‡ä»¶å†…çš„uart_receive_inputå‡½æ•°,å¹¶å°†æ¥æ”¶åˆ°çš„å­—èŠ‚ä
             -½œä¸ºå‚æ•°ä¼ å…¥
  74          5:å•ç‰‡æœºè¿›å…¥whileå¾ªç¯åè°ƒç”¨mcu_api.cæ–‡ä»¶å†…çš„wifi_uart_service()å‡½æ•°
  75          ******************************************************************************/
  76          
  77          /******************************************************************************
  78                                  1:dpæ•°æ®ç‚¹åºåˆ—ç±»å‹å¯¹ç…§è¡¨
  79                    **æ­¤ä¸ºè‡ªåŠ¨ç”Ÿæˆä»£ç ,å¦‚åœ¨å¼€å‘å¹³å°æœ‰ç›¸å…³ä¿®æ”¹è¯·é‡æ–°ä¸‹è½½MCU_SDK**         
  80          ******************************************************************************/
  81          const DOWNLOAD_CMD_S download_cmd[] =
  82          {
  83            {DPID_TEMP_CURRENT, DP_TYPE_VALUE},
  84            {DPID_HUMIDITY_VALUE, DP_TYPE_VALUE},
  85            {DPID_TEMP_SAMPLING, DP_TYPE_VALUE},
  86            {DPID_HUMIDITY_SAMPLING, DP_TYPE_VALUE},
  87            {DPID_MAXTEMP_SET, DP_TYPE_VALUE},
  88            {DPID_MINITEMP_SET, DP_TYPE_VALUE},
  89            {DPID_MAXHUM_SET, DP_TYPE_VALUE},
  90            {DPID_MINIHUM_SET, DP_TYPE_VALUE},
  91            {DPID_TEMP_ALARM, DP_TYPE_ENUM},
  92            {DPID_HUM_ALARM, DP_TYPE_ENUM},
  93            {DPID_BRIGHT_VALUE, DP_TYPE_VALUE},
  94            {DPID_DATA_IS, DP_TYPE_STRING},
  95          };
  96          
  97          
  98          
  99          /******************************************************************************
 100                                     2:ä¸²å£å•å­—èŠ‚å‘é€å‡½æ•°
 101          è¯·å°†MCUä¸²å£å‘é€å‡½æ•°å¡«å…¥è¯¥å‡½æ•°å†…,å¹¶å°†æ¥æ”¶åˆ°çš„æ•°æ®ä½œä¸ºå‚æ•°ä¼ å…¥ä¸²å£å‘é€å‡½æ•°
 102          ******************************************************************************/
 103          
 104          /**
 105           * @brief  ä¸²å£å‘é€æ•°æ®
 106           * @param[in] {value} ä¸²å£è¦å‘é€çš„1å­—èŠ‚æ•°æ®
 107           * @return Null
 108           */
 109          void uart_transmit_output(unsigned char value)
 110          {
 111   1      //    #error "è¯·å°†MCUä¸²å£å‘é€å‡½æ•°å¡«å…¥è¯¥å‡½æ•°,å¹¶åˆ é™¤è¯¥è¡Œ"
C51 COMPILER V9.54   PROTOCOL                                                              02/26/2021 13:53:45 PAGE 3   

 112   1          Printchar2(value);//å‘å­—ç¬¦=========================================================================
             -=========
 113   1      /*
 114   1          //Example:
 115   1          extern void Uart_PutChar(unsigned char value);
 116   1          Uart_PutChar(value);                                  //ä¸²å£å‘é€å‡½æ•°
 117   1      */
 118   1      }
 119          
 120          
 121          
 122          
 123          
 124          
 125          
 126          
 127          
 128          /******************************************************************************
 129                                     ç¬¬äºŒæ­¥:å®ç°å…·ä½“ç”¨æˆ·å‡½æ•°
 130          1:APPä¸‹å‘æ•°æ®å¤„ç†
 131          2:æ•°æ®ä¸ŠæŠ¥å¤„ç†
 132          ******************************************************************************/
 133          
 134          /******************************************************************************
 135                                      1:æ‰€æœ‰æ•°æ®ä¸ŠæŠ¥å¤„ç†
 136          å½“å‰å‡½æ•°å¤„ç†å…¨éƒ¨æ•°æ®ä¸ŠæŠ¥(åŒ…æ‹¬å¯ä¸‹å‘/å¯ä¸ŠæŠ¥å’Œåªä¸ŠæŠ¥)
 137            éœ€è¦ç”¨æˆ·æŒ‰ç…§å®é™…æƒ…å†µå®ç°:
 138            1:éœ€è¦å®ç°å¯ä¸‹å‘/å¯ä¸ŠæŠ¥æ•°æ®ç‚¹ä¸ŠæŠ¥
 139            2:éœ€è¦å®ç°åªä¸ŠæŠ¥æ•°æ®ç‚¹ä¸ŠæŠ¥
 140          æ­¤å‡½æ•°ä¸ºMCUå†…éƒ¨å¿…é¡»è°ƒç”¨
 141          ç”¨æˆ·ä¹Ÿå¯è°ƒç”¨æ­¤å‡½æ•°å®ç°å…¨éƒ¨æ•°æ®ä¸ŠæŠ¥
 142          ******************************************************************************/
 143          
 144          //è‡ªåŠ¨åŒ–ç”Ÿæˆæ•°æ®ä¸ŠæŠ¥å‡½æ•°
 145          
 146          /**
 147           * @brief  ç³»ç»Ÿæ‰€æœ‰dpç‚¹ä¿¡æ¯ä¸Šä¼ ,å®ç°APPå’Œmucæ•°æ®åŒæ­¥
 148           * @param  Null
 149           * @return Null
 150           * @note   æ­¤å‡½æ•°SDKå†…éƒ¨éœ€è°ƒç”¨ï¼ŒMCUå¿…é¡»å®ç°è¯¥å‡½æ•°å†…æ•°æ®ä¸ŠæŠ¥åŠŸèƒ½ï¼ŒåŒ…æ‹¬åªä¸ŠæŠ¥å’
             -Œå¯ä¸ŠæŠ¥å¯ä¸‹å‘å‹æ•°æ®
 151           */
 152          void all_data_update(void)
 153          {
 154   1      //    #error "è¯·åœ¨æ­¤å¤„ç†å¯ä¸‹å‘å¯ä¸ŠæŠ¥æ•°æ®åŠåªä¸ŠæŠ¥æ•°æ®ç¤ºä¾‹,å¤„ç†å®Œæˆååˆ é™¤è¯¥è¡Œ"
 155   1        
 156   1          mcu_dp_value_update(DPID_TEMP_CURRENT,temper); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;å½“å‰æ¸©åº¦
 157   1          mcu_dp_value_update(DPID_HUMIDITY_VALUE,humidity); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;å½“å‰å½“å‰æ¹¿åº¦
 158   1          mcu_dp_value_update(DPID_TEMP_SAMPLING,CY_T_time); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;å½“å‰æ¸©åº¦é‡‡æ ·æ—¶é—´è®¾ç
             -½®
 159   1          mcu_dp_value_update(DPID_HUMIDITY_SAMPLING,CY_H_time); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;å½“å‰æ¹¿åº¦é‡‡æ ·æ—¶é—´
             -è®¾ç½®
 160   1          mcu_dp_value_update(DPID_MAXTEMP_SET,most_T); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;å½“å‰æ¸©åº¦ä¸Šé™è®¾ç½®
 161   1          mcu_dp_value_update(DPID_MINITEMP_SET,least_T); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;å½“å‰æ¸©åº¦ä¸‹é™è®¾ç½®
 162   1          mcu_dp_value_update(DPID_MAXHUM_SET,most_humidity); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;å½“å‰æ¹¿åº¦ä¸Šé™è®¾ç½®
 163   1          mcu_dp_value_update(DPID_MINIHUM_SET,least_humidity); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;å½“å‰æ¹¿åº¦ä¸‹é™è®¾ç½®
 164   1          mcu_dp_enum_update(DPID_TEMP_ALARM,JB_T); //æšä¸¾å‹æ•°æ®ä¸ŠæŠ¥;å½“å‰æ¸©åº¦æŠ¥è­¦
 165   1          mcu_dp_enum_update(DPID_HUM_ALARM,JB_humidity); //æšä¸¾å‹æ•°æ®ä¸ŠæŠ¥;å½“å‰æ¹¿åº¦æŠ¥è­¦
 166   1          mcu_dp_value_update(DPID_BRIGHT_VALUE,sun); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;
 167   1          mcu_dp_string_update(DPID_DATA_IS,&DATA[0],DATA_long); //STRINGå‹æ•°æ®ä¸ŠæŠ¥;å½“å‰DATAæŒ‡é’ˆ,å½“å‰
             -DATAæ•°æ®é•¿åº¦
 168   1      
C51 COMPILER V9.54   PROTOCOL                                                              02/26/2021 13:53:45 PAGE 4   

 169   1        
 170   1          /*
 171   1          //æ­¤ä»£ç ä¸ºå¹³å°è‡ªåŠ¨ç”Ÿæˆï¼Œè¯·æŒ‰ç…§å®é™…æ•°æ®ä¿®æ”¹æ¯ä¸ªå¯ä¸‹å‘å¯ä¸ŠæŠ¥å‡½æ•°å’Œåªä¸Šæ
             -Š¥å‡½æ•°
 172   1          mcu_dp_value_update(DPID_TEMP_CURRENT,å½“å‰å½“å‰æ¸©åº¦); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;
 173   1          mcu_dp_value_update(DPID_HUMIDITY_VALUE,å½“å‰å½“å‰æ¹¿åº¦); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;
 174   1          mcu_dp_value_update(DPID_TEMP_SAMPLING,å½“å‰æ¸©åº¦é‡‡æ ·æ—¶é—´è®¾ç½®); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;
 175   1          mcu_dp_value_update(DPID_HUMIDITY_SAMPLING,å½“å‰æ¹¿åº¦é‡‡æ ·æ—¶é—´è®¾ç½®); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;
 176   1          mcu_dp_value_update(DPID_MAXTEMP_SET,å½“å‰æ¸©åº¦ä¸Šé™è®¾ç½®); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;
 177   1          mcu_dp_value_update(DPID_MINITEMP_SET,å½“å‰æ¸©åº¦ä¸‹é™è®¾ç½®); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;
 178   1          mcu_dp_value_update(DPID_MAXHUM_SET,å½“å‰æ¹¿åº¦ä¸Šé™è®¾ç½®); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;
 179   1          mcu_dp_value_update(DPID_MINIHUM_SET,å½“å‰æ¹¿åº¦ä¸‹é™è®¾ç½®); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;
 180   1          mcu_dp_enum_update(DPID_TEMP_ALARM,å½“å‰æ¸©åº¦æŠ¥è­¦); //æšä¸¾å‹æ•°æ®ä¸ŠæŠ¥;
 181   1          mcu_dp_enum_update(DPID_HUM_ALARM,å½“å‰æ¹¿åº¦æŠ¥è­¦); //æšä¸¾å‹æ•°æ®ä¸ŠæŠ¥;
 182   1          mcu_dp_value_update(DPID_BRIGHT_VALUE,å½“å‰å½“å‰äº®åº¦å€¼); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;
 183   1          mcu_dp_string_update(DPID_DATA_IS,å½“å‰DATAæŒ‡é’ˆ,å½“å‰DATAæ•°æ®é•¿åº¦); //STRINGå‹æ•°æ®ä¸ŠæŠ¥;
 184   1      
 185   1          */
 186   1      }
 187          
 188          
 189          /******************************************************************************
 190                                          WARNING!!!    
 191                                      2:æ‰€æœ‰æ•°æ®ä¸ŠæŠ¥å¤„ç†
 192          è‡ªåŠ¨åŒ–ä»£ç æ¨¡æ¿å‡½æ•°,å…·ä½“è¯·ç”¨æˆ·è‡ªè¡Œå®ç°æ•°æ®å¤„ç†
 193          ******************************************************************************/
 194          /*****************************************************************************
 195          å‡½æ•°åç§° : dp_download_temp_sampling_handle
 196          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_TEMP_SAMPLINGçš„å¤„ç†å‡½æ•°
 197          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 198                  : length:æ•°æ®é•¿åº¦
 199          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 200          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 201          *****************************************************************************/
 202          static unsigned char dp_download_temp_sampling_handle(const unsigned char value[], unsigned short length)
 203          {
 204   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºVALUE
 205   1          unsigned char ret;
 206   1          unsigned long temp_sampling;
 207   1          
 208   1          temp_sampling = mcu_get_dp_download_value(value,length);
 209   1          /*
 210   1          //VALUEç±»å‹æ•°æ®å¤„ç†
 211   1          
 212   1          */
 213   1          
 214   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 215   1          ret = mcu_dp_value_update(DPID_TEMP_SAMPLING,temp_sampling);
 216   1          if(ret == SUCCESS)
 217   1              return SUCCESS;
 218   1          else
 219   1              return ERROR;
 220   1      }
 221          /*****************************************************************************
 222          å‡½æ•°åç§° : dp_download_humidity_sampling_handle
 223          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_HUMIDITY_SAMPLINGçš„å¤„ç†å‡½æ•°
 224          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 225                  : length:æ•°æ®é•¿åº¦
 226          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 227          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 228          *****************************************************************************/
 229          static unsigned char dp_download_humidity_sampling_handle(const unsigned char value[], unsigned short leng
C51 COMPILER V9.54   PROTOCOL                                                              02/26/2021 13:53:45 PAGE 5   

             -th)
 230          {
 231   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºVALUE
 232   1          unsigned char ret;
 233   1          unsigned long humidity_sampling;
 234   1          
 235   1          humidity_sampling = mcu_get_dp_download_value(value,length);
 236   1          /*
 237   1          //VALUEç±»å‹æ•°æ®å¤„ç†
 238   1          
 239   1          */
 240   1          
 241   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 242   1          ret = mcu_dp_value_update(DPID_HUMIDITY_SAMPLING,humidity_sampling);
 243   1          if(ret == SUCCESS)
 244   1              return SUCCESS;
 245   1          else
 246   1              return ERROR;
 247   1      }
 248          /*****************************************************************************
 249          å‡½æ•°åç§° : dp_download_maxtemp_set_handle
 250          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_MAXTEMP_SETçš„å¤„ç†å‡½æ•°
 251          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 252                  : length:æ•°æ®é•¿åº¦
 253          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 254          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 255          *****************************************************************************/
 256          static unsigned char dp_download_maxtemp_set_handle(const unsigned char value[], unsigned short length)
 257          {
 258   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºVALUE
 259   1          unsigned char ret;
 260   1          unsigned long maxtemp_set;
 261   1          
 262   1          maxtemp_set = mcu_get_dp_download_value(value,length);
 263   1          /*
 264   1          //VALUEç±»å‹æ•°æ®å¤„ç†
 265   1          
 266   1          */
 267   1          
 268   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 269   1          ret = mcu_dp_value_update(DPID_MAXTEMP_SET,maxtemp_set);
 270   1          if(ret == SUCCESS)
 271   1              return SUCCESS;
 272   1          else
 273   1              return ERROR;
 274   1      }
 275          /*****************************************************************************
 276          å‡½æ•°åç§° : dp_download_minitemp_set_handle
 277          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_MINITEMP_SETçš„å¤„ç†å‡½æ•°
 278          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 279                  : length:æ•°æ®é•¿åº¦
 280          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 281          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 282          *****************************************************************************/
 283          static unsigned char dp_download_minitemp_set_handle(const unsigned char value[], unsigned short length)
 284          {
 285   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºVALUE
 286   1          unsigned char ret;
 287   1          unsigned long minitemp_set;
 288   1          
 289   1          minitemp_set = mcu_get_dp_download_value(value,length);
 290   1          /*
C51 COMPILER V9.54   PROTOCOL                                                              02/26/2021 13:53:45 PAGE 6   

 291   1          //VALUEç±»å‹æ•°æ®å¤„ç†
 292   1          
 293   1          */
 294   1          
 295   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 296   1          ret = mcu_dp_value_update(DPID_MINITEMP_SET,minitemp_set);
 297   1          if(ret == SUCCESS)
 298   1              return SUCCESS;
 299   1          else
 300   1              return ERROR;
 301   1      }
 302          /*****************************************************************************
 303          å‡½æ•°åç§° : dp_download_maxhum_set_handle
 304          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_MAXHUM_SETçš„å¤„ç†å‡½æ•°
 305          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 306                  : length:æ•°æ®é•¿åº¦
 307          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 308          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 309          *****************************************************************************/
 310          static unsigned char dp_download_maxhum_set_handle(const unsigned char value[], unsigned short length)
 311          {
 312   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºVALUE
 313   1          unsigned char ret;
 314   1          unsigned long maxhum_set;
 315   1          
 316   1          maxhum_set = mcu_get_dp_download_value(value,length);
 317   1          /*
 318   1          //VALUEç±»å‹æ•°æ®å¤„ç†
 319   1          
 320   1          */
 321   1          
 322   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 323   1          ret = mcu_dp_value_update(DPID_MAXHUM_SET,maxhum_set);
 324   1          if(ret == SUCCESS)
 325   1              return SUCCESS;
 326   1          else
 327   1              return ERROR;
 328   1      }
 329          /*****************************************************************************
 330          å‡½æ•°åç§° : dp_download_minihum_set_handle
 331          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_MINIHUM_SETçš„å¤„ç†å‡½æ•°
 332          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 333                  : length:æ•°æ®é•¿åº¦
 334          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 335          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 336          *****************************************************************************/
 337          static unsigned char dp_download_minihum_set_handle(const unsigned char value[], unsigned short length)
 338          {
 339   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºVALUE
 340   1          unsigned char ret;
 341   1          unsigned long minihum_set;
 342   1          
 343   1          minihum_set = mcu_get_dp_download_value(value,length);
 344   1          /*
 345   1          //VALUEç±»å‹æ•°æ®å¤„ç†
 346   1          
 347   1          */
 348   1          
 349   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 350   1          ret = mcu_dp_value_update(DPID_MINIHUM_SET,minihum_set);
 351   1          if(ret == SUCCESS)
 352   1              return SUCCESS;
C51 COMPILER V9.54   PROTOCOL                                                              02/26/2021 13:53:45 PAGE 7   

 353   1          else
 354   1              return ERROR;
 355   1      }
 356          /*****************************************************************************
 357          å‡½æ•°åç§° : dp_download_bright_value_handle
 358          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_BRIGHT_VALUEçš„å¤„ç†å‡½æ•°
 359          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 360                  : length:æ•°æ®é•¿åº¦
 361          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 362          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 363          *****************************************************************************/
 364          static unsigned char dp_download_bright_value_handle(const unsigned char value[], unsigned short length)
 365          {
 366   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºVALUE
 367   1          unsigned char ret;
 368   1          unsigned long bright_value;
 369   1          
 370   1          bright_value = mcu_get_dp_download_value(value,length);
 371   1          /*
 372   1          //VALUEç±»å‹æ•°æ®å¤„ç†
 373   1          
 374   1          */
 375   1          
 376   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 377   1          ret = mcu_dp_value_update(DPID_BRIGHT_VALUE,bright_value);
 378   1          if(ret == SUCCESS)
 379   1              return SUCCESS;
 380   1          else
 381   1              return ERROR;
 382   1      }
 383          /*****************************************************************************
 384          å‡½æ•°åç§° : dp_download_data_is_handle
 385          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_DATA_ISçš„å¤„ç†å‡½æ•°
 386          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 387                  : length:æ•°æ®é•¿åº¦
 388          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 389          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 390          *****************************************************************************/
 391          static unsigned char dp_download_data_is_handle(const unsigned char value[], unsigned short length)
 392          {
 393   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºSTRING
 394   1          unsigned char ret;
 395   1          /*
 396   1          //STRINGç±»å‹æ•°æ®å¤„ç†
 397   1          unsigned char string_data[8];
 398   1          
 399   1          string_data[0] = value[0];
 400   1          string_data[1] = value[1];
 401   1          string_data[2] = value[2];
 402   1          string_data[3] = value[3];
 403   1          string_data[4] = value[4];
 404   1          string_data[5] = value[5];
 405   1          string_data[6] = value[6];
 406   1          string_data[7] = value[7];
 407   1          */
 408   1          
 409   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 410   1          ret = mcu_dp_string_update(DPID_DATA_IS,value, length);
 411   1          if(ret == SUCCESS)
 412   1              return SUCCESS;
 413   1          else
 414   1              return ERROR;
C51 COMPILER V9.54   PROTOCOL                                                              02/26/2021 13:53:45 PAGE 8   

 415   1      }
 416          
 417          
 418          
 419          
 420          /******************************************************************************
 421                                          WARNING!!!                     
 422          æ­¤éƒ¨åˆ†å‡½æ•°ç”¨æˆ·è¯·å‹¿ä¿®æ”¹!!
 423          ******************************************************************************/
 424          
 425          /**
 426           * @brief  dpä¸‹å‘å¤„ç†å‡½æ•°
 427           * @param[in] {dpid} dpid åºå·
 428           * @param[in] {value} dpæ•°æ®ç¼“å†²åŒºåœ°å€
 429           * @param[in] {length} dpæ•°æ®é•¿åº¦
 430           * @return dpå¤„ç†ç»“æœ
 431           * -           0(ERROR): å¤±è´¥
 432           * -           1(SUCCESS): æˆåŠŸ
 433           * @note   è¯¥å‡½æ•°ç”¨æˆ·ä¸èƒ½ä¿®æ”¹
 434           */
 435          unsigned char dp_download_handle(unsigned char dpid,const unsigned char value[], unsigned short length)
 436          {
 437   1          /*********************************
 438   1          å½“å‰å‡½æ•°å¤„ç†å¯ä¸‹å‘/å¯ä¸ŠæŠ¥æ•°æ®è°ƒç”¨                    
 439   1          å…·ä½“å‡½æ•°å†…éœ€è¦å®ç°ä¸‹å‘æ•°æ®å¤„ç†
 440   1          å®Œæˆç”¨éœ€è¦å°†å¤„ç†ç»“æœåé¦ˆè‡³APPç«¯,å¦åˆ™APPä¼šè®¤ä¸ºä¸‹å‘å¤±è´¥
 441   1          ***********************************/
 442   1          unsigned char ret;
 443   1          switch(dpid) {
 444   2              case DPID_TEMP_SAMPLING:
 445   2                  //æ¸©åº¦é‡‡æ ·æ—¶é—´è®¾ç½®å¤„ç†å‡½æ•°
 446   2                  ret = dp_download_temp_sampling_handle(value,length);
 447   2              break;
 448   2              case DPID_HUMIDITY_SAMPLING:
 449   2                  //æ¹¿åº¦é‡‡æ ·æ—¶é—´è®¾ç½®å¤„ç†å‡½æ•°
 450   2                  ret = dp_download_humidity_sampling_handle(value,length);
 451   2              break;
 452   2              case DPID_MAXTEMP_SET:
 453   2                  //æ¸©åº¦ä¸Šé™è®¾ç½®å¤„ç†å‡½æ•°
 454   2                  ret = dp_download_maxtemp_set_handle(value,length);
 455   2              break;
 456   2              case DPID_MINITEMP_SET:
 457   2                  //æ¸©åº¦ä¸‹é™è®¾ç½®å¤„ç†å‡½æ•°
 458   2                  ret = dp_download_minitemp_set_handle(value,length);
 459   2              break;
 460   2              case DPID_MAXHUM_SET:
 461   2                  //æ¹¿åº¦ä¸Šé™è®¾ç½®å¤„ç†å‡½æ•°
 462   2                  ret = dp_download_maxhum_set_handle(value,length);
 463   2              break;
 464   2              case DPID_MINIHUM_SET:
 465   2                  //æ¹¿åº¦ä¸‹é™è®¾ç½®å¤„ç†å‡½æ•°
 466   2                  ret = dp_download_minihum_set_handle(value,length);
 467   2              break;
 468   2              case DPID_BRIGHT_VALUE:
 469   2                  //å½“å‰äº®åº¦å€¼å¤„ç†å‡½æ•°
 470   2                  ret = dp_download_bright_value_handle(value,length);
 471   2              break;
 472   2              case DPID_DATA_IS:
 473   2                  //DATAå¤„ç†å‡½æ•°
 474   2                  ret = dp_download_data_is_handle(value,length);
 475   2              break;
 476   2      
C51 COMPILER V9.54   PROTOCOL                                                              02/26/2021 13:53:45 PAGE 9   

 477   2              
 478   2              default:
 479   2              break;
 480   2          }
 481   1          return ret;
 482   1      }
 483          
 484          /**
 485           * @brief  è·å–æ‰€æœ‰dpå‘½ä»¤æ€»å’Œ
 486           * @param[in] Null
 487           * @return ä¸‹å‘å‘½ä»¤æ€»å’Œ
 488           * @note   è¯¥å‡½æ•°ç”¨æˆ·ä¸èƒ½ä¿®æ”¹
 489           */
 490          unsigned char get_download_cmd_total(void)
 491          {
 492   1          return(sizeof(download_cmd) / sizeof(download_cmd[0]));
 493   1      }
 494          
 495          
 496          /******************************************************************************
 497                                          WARNING!!!                     
 498          æ­¤ä»£ç ä¸ºSDKå†…éƒ¨è°ƒç”¨,è¯·æŒ‰ç…§å®é™…dpæ•°æ®å®ç°å‡½æ•°å†…éƒ¨æ•°æ®
 499          ******************************************************************************/
 500          
 501          #ifdef SUPPORT_MCU_FIRM_UPDATE
              /**
               * @brief  å‡çº§åŒ…å¤§å°é€‰æ‹©
               * @param[in] {package_sz} å‡çº§åŒ…å¤§å°
               * @ref           0x00: 256byte (é»˜è®¤)
               * @ref           0x01: 512byte
               * @ref           0x02: 1024byte
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void upgrade_package_choose(unsigned char package_sz)
              {
                  #error "è¯·è‡ªè¡Œå®ç°è¯·è‡ªè¡Œå®ç°å‡çº§åŒ…å¤§å°é€‰æ‹©ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  unsigned short send_len = 0;
                  send_len = set_wifi_uart_byte(send_len, package_sz);
                  wifi_uart_write_frame(UPDATE_START_CMD, MCU_TX_VER, send_len);
              }
              
              /**
               * @brief  MCUè¿›å…¥å›ºä»¶å‡çº§æ¨¡å¼
               * @param[in] {value} å›ºä»¶ç¼“å†²åŒº
               * @param[in] {position} å½“å‰æ•°æ®åŒ…åœ¨äºå›ºä»¶ä½ç½®
               * @param[in] {length} å½“å‰å›ºä»¶åŒ…é•¿åº¦(å›ºä»¶åŒ…é•¿åº¦ä¸º0æ—¶,è¡¨ç¤ºå›ºä»¶åŒ…å‘é€å®Œæˆ)
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              unsigned char mcu_firm_update_handle(const unsigned char value[],unsigned long position,unsigned short len
             -gth)
              {
                  #error "è¯·è‡ªè¡Œå®ŒæˆMCUå›ºä»¶å‡çº§ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  if(length == 0) {
                      //å›ºä»¶æ•°æ®å‘é€å®Œæˆ
                    
                  }else {
                      //å›ºä»¶æ•°æ®å¤„ç†
                    
                  }
                  
C51 COMPILER V9.54   PROTOCOL                                                              02/26/2021 13:53:45 PAGE 10  

                  return SUCCESS;
              }
              #endif
 541          
 542          #ifdef SUPPORT_GREEN_TIME
              /**
               * @brief  è·å–åˆ°çš„æ ¼æ—æ—¶é—´
               * @param[in] {time} è·å–åˆ°çš„æ ¼æ—æ—¶é—´æ•°æ®
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void mcu_get_greentime(unsigned char time[])
              {
                  #error "è¯·è‡ªè¡Œå®Œæˆç›¸å…³ä»£ç ,å¹¶åˆ é™¤è¯¥è¡Œ"
                  /*
                  time[0] ä¸ºæ˜¯å¦è·å–æ—¶é—´æˆåŠŸæ ‡å¿—ï¼Œä¸º 0 è¡¨ç¤ºå¤±è´¥ï¼Œä¸º 1è¡¨ç¤ºæˆåŠŸ
                  time[1] ä¸ºå¹´ä»½ï¼Œ0x00 è¡¨ç¤º 2000 å¹´
                  time[2] ä¸ºæœˆä»½ï¼Œä» 1 å¼€å§‹åˆ°12 ç»“æŸ
                  time[3] ä¸ºæ—¥æœŸï¼Œä» 1 å¼€å§‹åˆ°31 ç»“æŸ
                  time[4] ä¸ºæ—¶é’Ÿï¼Œä» 0 å¼€å§‹åˆ°23 ç»“æŸ
                  time[5] ä¸ºåˆ†é’Ÿï¼Œä» 0 å¼€å§‹åˆ°59 ç»“æŸ
                  time[6] ä¸ºç§’é’Ÿï¼Œä» 0 å¼€å§‹åˆ°59 ç»“æŸ
                  */
                  if(time[0] == 1) {
                      //æ­£ç¡®æ¥æ”¶åˆ°wifiæ¨¡å—è¿”å›çš„æ ¼æ—æ•°æ®
                      
                  }else {
                      //è·å–æ ¼æ—æ—¶é—´å‡ºé”™,æœ‰å¯èƒ½æ˜¯å½“å‰wifiæ¨¡å—æœªè”ç½‘
                  }
              }
              #endif
 569          
 570          #ifdef SUPPORT_MCU_RTC_CHECK
              /**
               * @brief  MCUæ ¡å¯¹æœ¬åœ°RTCæ—¶é’Ÿ
               * @param[in] {time} è·å–åˆ°çš„æ ¼æ—æ—¶é—´æ•°æ®
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void mcu_write_rtctime(unsigned char time[])
              {
              //    #error "è¯·è‡ªè¡Œå®ŒæˆRTCæ—¶é’Ÿå†™å…¥ä»£ç ,å¹¶åˆ é™¤è¯¥è¡Œ"
                  /*
                  Time[0] ä¸ºæ˜¯å¦è·å–æ—¶é—´æˆåŠŸæ ‡å¿—ï¼Œä¸º 0 è¡¨ç¤ºå¤±è´¥ï¼Œä¸º 1è¡¨ç¤ºæˆåŠŸ
                  Time[1] ä¸ºå¹´ä»½ï¼Œ0x00 è¡¨ç¤º 2000 å¹´
                  Time[2] ä¸ºæœˆä»½ï¼Œä» 1 å¼€å§‹åˆ°12 ç»“æŸ
                  Time[3] ä¸ºæ—¥æœŸï¼Œä» 1 å¼€å§‹åˆ°31 ç»“æŸ
                  Time[4] ä¸ºæ—¶é’Ÿï¼Œä» 0 å¼€å§‹åˆ°23 ç»“æŸ
                  Time[5] ä¸ºåˆ†é’Ÿï¼Œä» 0 å¼€å§‹åˆ°59 ç»“æŸ
                  Time[6] ä¸ºç§’é’Ÿï¼Œä» 0 å¼€å§‹åˆ°59 ç»“æŸ
                  Time[7] ä¸ºæ˜ŸæœŸï¼Œä» 1 å¼€å§‹åˆ° 7 ç»“æŸï¼Œ1ä»£è¡¨æ˜ŸæœŸä¸€
                 */
                  if(time[0] == 1) {
                      //æ­£ç¡®æ¥æ”¶åˆ°wifiæ¨¡å—è¿”å›çš„æœ¬åœ°æ—¶é’Ÿæ•°æ®
                    
                  int a = 7
                  while(a--)
                    {
              
                      Time_sys[a] = Time[a+1];
              
                    }
C51 COMPILER V9.54   PROTOCOL                                                              02/26/2021 13:53:45 PAGE 11  

                    
                   
                  }else {
                      //è·å–æœ¬åœ°æ—¶é’Ÿæ•°æ®å‡ºé”™,æœ‰å¯èƒ½æ˜¯å½“å‰wifiæ¨¡å—æœªè”ç½‘
                  }
              }
              #endif
 607          
 608          #ifdef WIFI_TEST_ENABLE
 609          /**
 610           * @brief  wifiåŠŸèƒ½æµ‹è¯•åé¦ˆ
 611           * @param[in] {result} wifiåŠŸèƒ½æµ‹è¯•ç»“æœ
 612           * @ref       0: å¤±è´¥
 613           * @ref       1: æˆåŠŸ
 614           * @param[in] {rssi} æµ‹è¯•æˆåŠŸè¡¨ç¤ºwifiä¿¡å·å¼ºåº¦/æµ‹è¯•å¤±è´¥è¡¨ç¤ºé”™è¯¯ç±»å‹
 615           * @return Null
 616           * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
 617           */
 618          void wifi_test_result(unsigned char result,unsigned char rssi)
 619          {
 620   1      //    #error "è¯·è‡ªè¡Œå®ç°wifiåŠŸèƒ½æµ‹è¯•æˆåŠŸ/å¤±è´¥ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
 621   1          if(result == 0) {
 622   2              //æµ‹è¯•å¤±è´¥
 623   2      //      PrintString1("æµ‹è¯•å¤±è´¥!\r\n");  //SUART1å‘é€ä¸€ä¸ªå­—ç¬¦ä¸²
 624   2                OLED_ShowCHinese(17,0,23);
 625   2                OLED_ShowCHinese(35,0,24);
 626   2                OLED_ShowCHinese(54,0,25);
 627   2                OLED_ShowCHinese(74,0,26);//æœªçŸ¥çŠ¶æ€
 628   2                OLED_ShowCHinese(95,0,20);
 629   2            
 630   2              if(rssi == 0x00) {
 631   3                  //æœªæ‰«æåˆ°åç§°ä¸ºtuya_mdev_testè·¯ç”±å™¨,è¯·æ£€æŸ¥
 632   3      //          PrintString1("æœªæ‰«æåˆ°åç§°ä¸ºtuya_mdev_testè·¯ç”±å™¨,è¯·æ£€æŸ¥!\r\n");  //SUART1å‘é€ä¸€ä¸ªå­
             -—ç¬¦ä¸²
 633   3                OLED_ShowCHinese(17,0,9);//å¾…
 634   3                OLED_ShowCHinese(35,0,15);
 635   3                OLED_ShowCHinese(54,0,16);//è¿æ¥
 636   3                OLED_ShowCHinese(74,0,12);
 637   3                OLED_ShowCHinese(95,0,13);
 638   3                OLED_ShowCHinese(117,0,14);//è·¯ç”±å™¨
 639   3                OLED_ShowCHinese(140,0,20);
 640   3                
 641   3              }else if(rssi == 0x01) {
 642   3                  //æ¨¡å—æœªæˆæƒ
 643   3      //          PrintString1("æ¨¡å—æœªæˆæƒ!\r\n"); //SUART1å‘é€ä¸€ä¸ªå­—ç¬¦ä¸²
 644   3                OLED_ShowCHinese(17,0,23);
 645   3                OLED_ShowCHinese(35,0,24);
 646   3                OLED_ShowCHinese(54,0,25);
 647   3                OLED_ShowCHinese(74,0,26);//æœªçŸ¥çŠ¶æ€
 648   3                OLED_ShowCHinese(95,0,20);
 649   3              }
 650   2          }else {
 651   2              //æµ‹è¯•æˆåŠŸ
 652   2      //      PrintString1("æµ‹è¯•æˆåŠŸ!\r\n");  //SUART1å‘é€ä¸€ä¸ªå­—ç¬¦ä¸²
 653   2            OLED_ShowString(17,0,"OK",12);
 654   2              //rssiä¸ºä¿¡å·å¼ºåº¦(0-100, 0ä¿¡å·æœ€å·®ï¼Œ100ä¿¡å·æœ€å¼º)
 655   2      //      PrintN1(rssi);//å‘æ•°å€¼
 656   2            OLED_ShowString(17,2,"rssi:",12);
 657   2            OLED_ShowNum(17,4,rssi,2,16);
 658   2          }
 659   1      }
 660          #endif
C51 COMPILER V9.54   PROTOCOL                                                              02/26/2021 13:53:45 PAGE 12  

 661          
 662          #ifdef WEATHER_ENABLE
              /**
              * @brief  mcuæ‰“å¼€å¤©æ°”æœåŠ¡
               * @param  Null
               * @return Null
               */
              void mcu_open_weather(void)
              {
                  int i = 0;
                  char buffer[13] = {0};
                  unsigned char weather_len = 0;
                  unsigned short send_len = 0;
                  
                  weather_len = sizeof(weather_choose) / sizeof(weather_choose[0]);
                    
                  for(i=0;i<weather_len;i++) {
                      buffer[0] = sprintf(buffer+1,"w.%s",weather_choose[i]);
                      send_len = set_wifi_uart_buffer(send_len, (unsigned char *)buffer, buffer[0]+1);
                  }
                  
                  #error "è¯·æ ¹æ®æç¤ºï¼Œè‡ªè¡Œå®Œå–„æ‰“å¼€å¤©æ°”æœåŠ¡ä»£ç ï¼Œå®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  /*
                  //å½“è·å–çš„å‚æ•°æœ‰å’Œæ—¶é—´æœ‰å…³çš„å‚æ•°æ—¶(å¦‚:æ—¥å‡ºæ—¥è½)ï¼Œéœ€è¦æ­é…t.unixæˆ–è€…t.local
             -ä½¿ç”¨ï¼Œéœ€è¦è·å–çš„å‚æ•°æ•°æ®æ˜¯æŒ‰ç…§æ ¼æ—æ—¶é—´è¿˜æ˜¯æœ¬åœ°æ—¶é—´
                  buffer[0] = sprintf(buffer+1,"t.unix"); //æ ¼æ—æ—¶é—´   æˆ–ä½¿ç”¨  buffer[0] = sprintf(buffer+1,"t.lo
             -cal"); //æœ¬åœ°æ—¶é—´
                  send_len = set_wifi_uart_buffer(send_len, (unsigned char *)buffer, buffer[0]+1);
                  */
                  
                  buffer[0] = sprintf(buffer+1,"w.date.%d",WEATHER_FORECAST_DAYS_NUM);
                  send_len = set_wifi_uart_buffer(send_len, (unsigned char *)buffer, buffer[0]+1);
                  
                  wifi_uart_write_frame(WEATHER_OPEN_CMD, MCU_TX_VER, send_len);
              }
              
              /**
               * @brief  æ‰“å¼€å¤©æ°”åŠŸèƒ½è¿”å›ç”¨æˆ·è‡ªå¤„ç†å‡½æ•°
               * @param[in] {res} æ‰“å¼€å¤©æ°”åŠŸèƒ½è¿”å›ç»“æœ
               * @ref       0: å¤±è´¥
               * @ref       1: æˆåŠŸ
               * @param[in] {err} é”™è¯¯ç 
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void weather_open_return_handle(unsigned char res, unsigned char err)
              {
                  #error "è¯·è‡ªè¡Œå®Œæˆæ‰“å¼€å¤©æ°”åŠŸèƒ½è¿”å›æ•°æ®å¤„ç†ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  unsigned char err_num = 0;
                  
                  if(res == 1) {
                      //æ‰“å¼€å¤©æ°”è¿”å›æˆåŠŸ
                  }else if(res == 0) {
                      //æ‰“å¼€å¤©æ°”è¿”å›å¤±è´¥
                      //è·å–é”™è¯¯ç 
                      err_num = err; 
                  }
              }
              
              /**
               * @brief  å¤©æ°”æ•°æ®ç”¨æˆ·è‡ªå¤„ç†å‡½æ•°
               * @param[in] {name} å‚æ•°å
C51 COMPILER V9.54   PROTOCOL                                                              02/26/2021 13:53:45 PAGE 13  

               * @param[in] {type} å‚æ•°ç±»å‹
               * @ref       0: int å‹
               * @ref       1: string å‹
               * @param[in] {data} å‚æ•°å€¼çš„åœ°å€
               * @param[in] {day} å“ªä¸€å¤©çš„å¤©æ°”  0:è¡¨ç¤ºå½“å¤© å–å€¼èŒƒå›´: 0~6
               * @ref       0: ä»Šå¤©
               * @ref       1: æ˜å¤©
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void weather_data_user_handle(char *name, unsigned char type, const unsigned char *data, char day)
              {
                  #error "è¿™é‡Œä»…ç»™å‡ºç¤ºä¾‹ï¼Œè¯·è‡ªè¡Œå®Œå–„å¤©æ°”æ•°æ®å¤„ç†ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  int value_int;
                  char value_string[50];//ç”±äºæœ‰çš„å‚æ•°å†…å®¹è¾ƒå¤šï¼Œè¿™é‡Œé»˜è®¤ä¸º50ã€‚æ‚¨å¯ä»¥æ ¹æ®å®šä¹‰çš„å
             -‚æ•°ï¼Œå¯ä»¥é€‚å½“å‡å°‘è¯¥å€¼
                  
                  my_memset(value_string, '\0', 50);
                  
                  //é¦–å…ˆè·å–æ•°æ®ç±»å‹
                  if(type == 0) { //å‚æ•°æ˜¯INTå‹
                      value_int = data[0] << 24 | data[1] << 16 | data[2] << 8 | data[3];
                  }else if(type == 1) {
                      my_strcpy(value_string, data);
                  }
                  
                  //æ³¨æ„è¦æ ¹æ®æ‰€é€‰å‚æ•°ç±»å‹æ¥è·å¾—å‚æ•°å€¼ï¼ï¼ï¼
                  if(my_strcmp(name, "temp") == 0) {
                      printf("day:%d temp value is:%d\r\n", day, value_int);          //int å‹
                  }else if(my_strcmp(name, "humidity") == 0) {
                      printf("day:%d humidity value is:%d\r\n", day, value_int);      //int å‹
                  }else if(my_strcmp(name, "pm25") == 0) {
                      printf("day:%d pm25 value is:%d\r\n", day, value_int);          //int å‹
                  }else if(my_strcmp(name, "condition") == 0) {
                      printf("day:%d condition value is:%s\r\n", day, value_string);  //string å‹
                  }
              }
              #endif
 758          
 759          #ifdef MCU_DP_UPLOAD_SYN
              /**
               * @brief  çŠ¶æ€åŒæ­¥ä¸ŠæŠ¥ç»“æœ
               * @param[in] {result} ç»“æœ
               * @ref       0: å¤±è´¥
               * @ref       1: æˆåŠŸ
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void get_upload_syn_result(unsigned char result)
              {
                  #error "è¯·è‡ªè¡Œå®ŒæˆçŠ¶æ€åŒæ­¥ä¸ŠæŠ¥ç»“æœä»£ç ,å¹¶åˆ é™¤è¯¥è¡Œ"
                    
                  if(result == 0) {
                      //åŒæ­¥ä¸ŠæŠ¥å‡ºé”™
                  }else {
                      //åŒæ­¥ä¸ŠæŠ¥æˆåŠŸ
                  }
              }
              #endif
 779          
 780          #ifdef GET_WIFI_STATUS_ENABLE
              /**
C51 COMPILER V9.54   PROTOCOL                                                              02/26/2021 13:53:45 PAGE 14  

               * @brief  è·å– WIFI çŠ¶æ€ç»“æœ
               * @param[in] {result} æŒ‡ç¤º WIFI å·¥ä½œçŠ¶æ€
               * @ref       0x00: wifiçŠ¶æ€ 1 smartconfig é…ç½®çŠ¶æ€
               * @ref       0x01: wifiçŠ¶æ€ 2 AP é…ç½®çŠ¶æ€
               * @ref       0x02: wifiçŠ¶æ€ 3 WIFI å·²é…ç½®ä½†æœªè¿ä¸Šè·¯ç”±å™¨
               * @ref       0x03: wifiçŠ¶æ€ 4 WIFI å·²é…ç½®ä¸”è¿ä¸Šè·¯ç”±å™¨
               * @ref       0x04: wifiçŠ¶æ€ 5 å·²è¿ä¸Šè·¯ç”±å™¨ä¸”è¿æ¥åˆ°äº‘ç«¯
               * @ref       0x05: wifiçŠ¶æ€ 6 WIFI è®¾å¤‡å¤„äºä½åŠŸè€—æ¨¡å¼
               * @ref       0x06: wifiçŠ¶æ€ 7 WIFI è®¾å¤‡å¤„äºsmartconfig&APé…ç½®çŠ¶æ€
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void get_wifi_status(unsigned char result)
              {
                #error "è¯·è‡ªè¡Œå®Œæˆè·å– WIFI çŠ¶æ€ç»“æœä»£ç ,å¹¶åˆ é™¤è¯¥è¡Œ"
               
                  switch(result) {
                      case 0:
                          //wifiå·¥ä½œçŠ¶æ€1
                      break;
                  
                      case 1:
                          //wifiå·¥ä½œçŠ¶æ€2
                      break;
                      
                      case 2:
                          //wifiå·¥ä½œçŠ¶æ€3
                      break;
                      
                      case 3:
                          //wifiå·¥ä½œçŠ¶æ€4
                      break;
                      
                      case 4:
                          //wifiå·¥ä½œçŠ¶æ€5
                      break;
                      
                      case 5:
                          //wifiå·¥ä½œçŠ¶æ€6
                      break;
                    
                      case 6:
                          //wifiå·¥ä½œçŠ¶æ€7
                      break;
                      
                      default:break;
                  }
              }
              #endif
 831          
 832          #ifdef WIFI_STREAM_ENABLE
              /**
               * @brief  æµæœåŠ¡å‘é€ç»“æœ
               * @param[in] {result} ç»“æœ
               * @ref       0x00: æˆåŠŸ
               * @ref       0x01: æµæœåŠ¡åŠŸèƒ½æœªå¼€å¯
               * @ref       0x02: æµæœåŠ¡å™¨æœªè¿æ¥æˆåŠŸ
               * @ref       0x03: æ•°æ®æ¨é€è¶…æ—¶
               * @ref       0x04: ä¼ è¾“çš„æ•°æ®é•¿åº¦é”™è¯¯
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
C51 COMPILER V9.54   PROTOCOL                                                              02/26/2021 13:53:45 PAGE 15  

              void stream_trans_send_result(unsigned char result)
              {
                  #error "è¿™é‡Œä»…ç»™å‡ºç¤ºä¾‹ï¼Œè¯·è‡ªè¡Œå®Œå–„æµæœåŠ¡å‘é€ç»“æœå¤„ç†ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥
             -è¡Œ"
                  switch(result) {
                      case 0x00:
                          //æˆåŠŸ
                      break;
                      
                      case 0x01:
                          //æµæœåŠ¡åŠŸèƒ½æœªå¼€å¯
                      break;
                      
                      case 0x02:
                          //æµæœåŠ¡å™¨æœªè¿æ¥æˆåŠŸ
                      break;
                      
                      case 0x03:
                          //æ•°æ®æ¨é€è¶…æ—¶
                      break;
                      
                      case 0x04:
                          //ä¼ è¾“çš„æ•°æ®é•¿åº¦é”™è¯¯
                      break;
                      
                      default:break;
                  }
              }
              
              /**
               * @brief  å¤šåœ°å›¾æµæœåŠ¡å‘é€ç»“æœ
               * @param[in] {result} ç»“æœ
               * @ref       0x00: æˆåŠŸ
               * @ref       0x01: å¤±è´¥
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void maps_stream_trans_send_result(unsigned char result)
              {
                  #error "è¿™é‡Œä»…ç»™å‡ºç¤ºä¾‹ï¼Œè¯·è‡ªè¡Œå®Œå–„å¤šåœ°å›¾æµæœåŠ¡å‘é€ç»“æœå¤„ç†ä»£ç ,å®Œæˆåè¯·
             -åˆ é™¤è¯¥è¡Œ"
                  switch(result) {
                      case 0x00:
                          //æˆåŠŸ
                      break;
                      
                      case 0x01:
                          //å¤±è´¥
                      break;
                      
                      default:break;
                  }
              }
              #endif
 896          
 897          #ifdef WIFI_CONNECT_TEST_ENABLE
              /**
               * @brief  è·¯ç”±ä¿¡æ¯æ¥æ”¶ç»“æœé€šçŸ¥
               * @param[in] {result} æ¨¡å—æ˜¯å¦æˆåŠŸæ¥æ”¶åˆ°æ­£ç¡®çš„è·¯ç”±ä¿¡æ¯
               * @ref       0x00: å¤±è´¥
               * @ref       0x01: æˆåŠŸ
               * @return Null
C51 COMPILER V9.54   PROTOCOL                                                              02/26/2021 13:53:45 PAGE 16  

               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void wifi_connect_test_result(unsigned char result)
              {
                  #error "è¯·è‡ªè¡Œå®ç°wifiåŠŸèƒ½æµ‹è¯•æˆåŠŸ/å¤±è´¥ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  if(result == 0) {
                      //è·¯ç”±ä¿¡æ¯æ¥æ”¶å¤±è´¥ï¼Œè¯·æ£€æŸ¥å‘å‡ºçš„è·¯ç”±ä¿¡æ¯åŒ…æ˜¯å¦æ˜¯å®Œæ•´çš„JSONæ•°æ®åŒ…
                  }else {
                      //è·¯ç”±ä¿¡æ¯æ¥æ”¶æˆåŠŸï¼Œäº§æµ‹ç»“æœè¯·æ³¨æ„WIFI_STATE_CMDæŒ‡ä»¤çš„wifiå·¥ä½œçŠ¶æ€
                  }
              }
              #endif
 916          
 917          #ifdef GET_MODULE_MAC_ENABLE
              /**
               * @brief  è·å–æ¨¡å—macç»“æœ
               * @param[in] {mac} æ¨¡å— MAC æ•°æ®
               * @ref       mac[0]: ä¸ºæ˜¯å¦è·å–macæˆåŠŸæ ‡å¿—ï¼Œ0x00 è¡¨ç¤ºæˆåŠŸï¼Œ0x01 è¡¨ç¤ºå¤±è´¥
               * @ref       mac[1]~mac[6]: å½“è·å– MACåœ°å€æ ‡å¿—ä½å¦‚æœmac[0]ä¸ºæˆåŠŸï¼Œåˆ™è¡¨ç¤ºæ¨¡å—æœ‰æ•ˆçš„M
             -ACåœ°å€
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void mcu_get_mac(unsigned char mac[])
              {
                  #error "è¯·è‡ªè¡Œå®Œæˆmacè·å–ä»£ç ,å¹¶åˆ é™¤è¯¥è¡Œ"
                  /*
                  mac[0]ä¸ºæ˜¯å¦è·å–macæˆåŠŸæ ‡å¿—ï¼Œ0x00 è¡¨ç¤ºæˆåŠŸï¼Œä¸º0x01è¡¨ç¤ºå¤±è´¥
                  mac[1]~mac[6]:å½“è·å– MACåœ°å€æ ‡å¿—ä½å¦‚æœmac[0]ä¸ºæˆåŠŸï¼Œåˆ™è¡¨ç¤ºæ¨¡å—æœ‰æ•ˆçš„MACåœ°å€
                 */
                 
                  if(mac[0] == 1) {
                      //è·å–macå‡ºé”™
                  }else {
                      //æ­£ç¡®æ¥æ”¶åˆ°wifiæ¨¡å—è¿”å›çš„macåœ°å€
                  }
              }
              #endif
 941          
 942          #ifdef GET_IR_STATUS_ENABLE
              /**
               * @brief  è·å–çº¢å¤–çŠ¶æ€ç»“æœ
               * @param[in] {result} æŒ‡ç¤ºçº¢å¤–çŠ¶æ€
               * @ref       0x00: çº¢å¤–çŠ¶æ€ 1 æ­£åœ¨å‘é€çº¢å¤–ç 
               * @ref       0x01: çº¢å¤–çŠ¶æ€ 2 å‘é€çº¢å¤–ç ç»“æŸ
               * @ref       0x02: çº¢å¤–çŠ¶æ€ 3 çº¢å¤–å­¦ä¹ å¼€å§‹
               * @ref       0x03: çº¢å¤–çŠ¶æ€ 4 çº¢å¤–å­¦ä¹ ç»“æŸ
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void get_ir_status(unsigned char result)
              {
                  #error "è¯·è‡ªè¡Œå®Œæˆçº¢å¤–çŠ¶æ€ä»£ç ,å¹¶åˆ é™¤è¯¥è¡Œ"
                  switch(result) {
                      case 0:
                          //çº¢å¤–çŠ¶æ€ 1
                      break;
                    
                      case 1:
                          //çº¢å¤–çŠ¶æ€ 2
                      break;
                        
C51 COMPILER V9.54   PROTOCOL                                                              02/26/2021 13:53:45 PAGE 17  

                      case 2:
                          //çº¢å¤–çŠ¶æ€ 3
                      break;
                        
                      case 3:
                          //çº¢å¤–çŠ¶æ€ 4
                      break;
                        
                      default:break;
                  }
                  
                  wifi_uart_write_frame(GET_IR_STATUS_CMD, MCU_TX_VER, 0);
              }
              #endif
 979          
 980          #ifdef IR_TX_RX_TEST_ENABLE
              /**
               * @brief  çº¢å¤–è¿›å…¥æ”¶å‘äº§æµ‹ç»“æœé€šçŸ¥
               * @param[in] {result} æ¨¡å—æ˜¯å¦æˆåŠŸæ¥æ”¶åˆ°æ­£ç¡®çš„ä¿¡æ¯
               * @ref       0x00: å¤±è´¥
               * @ref       0x01: æˆåŠŸ
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void ir_tx_rx_test_result(unsigned char result)
              {
                  #error "è¯·è‡ªè¡Œå®ç°çº¢å¤–è¿›å…¥æ”¶å‘äº§æµ‹åŠŸèƒ½æµ‹è¯•æˆåŠŸ/å¤±è´¥ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡
             -Œ"
                  if(result == 0) {
                      //çº¢å¤–è¿›å…¥æ”¶å‘äº§æµ‹æˆåŠŸ
                  }else {
                      //çº¢å¤–è¿›å…¥æ”¶å‘äº§æµ‹å¤±è´¥ï¼Œè¯·æ£€æŸ¥å‘å‡ºçš„æ•°æ®åŒ…
                  }
              }
              #endif
 999          
1000          #ifdef FILE_DOWNLOAD_ENABLE
              /**
               * @brief  æ–‡ä»¶ä¸‹è½½åŒ…å¤§å°é€‰æ‹©
               * @param[in] {package_sz} æ–‡ä»¶ä¸‹è½½åŒ…å¤§å°
               * @ref       0x00: 256 byte (é»˜è®¤)
               * @ref       0x01: 512 byte
               * @ref       0x02: 1024 byte
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void file_download_package_choose(unsigned char package_sz)
              {
                  #error "è¯·è‡ªè¡Œå®ç°è¯·è‡ªè¡Œå®ç°æ–‡ä»¶ä¸‹è½½åŒ…å¤§å°é€‰æ‹©ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  unsigned short send_len = 0;
                  send_len = set_wifi_uart_byte(send_len, package_sz);
                  wifi_uart_write_frame(FILE_DOWNLOAD_START_CMD, MCU_TX_VER, send_len);
              }
              
              /**
               * @brief  æ–‡ä»¶åŒ…ä¸‹è½½æ¨¡å¼
               * @param[in] {value} æ•°æ®ç¼“å†²åŒº
               * @param[in] {position} å½“å‰æ•°æ®åŒ…åœ¨äºæ–‡ä»¶ä½ç½®
               * @param[in] {length} å½“å‰æ–‡ä»¶åŒ…é•¿åº¦(é•¿åº¦ä¸º0æ—¶,è¡¨ç¤ºæ–‡ä»¶åŒ…å‘é€å®Œæˆ)
               * @return æ•°æ®å¤„ç†ç»“æœ
               * -           0(ERROR): å¤±è´¥
               * -           1(SUCCESS): æˆåŠŸ
C51 COMPILER V9.54   PROTOCOL                                                              02/26/2021 13:53:45 PAGE 18  

               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              unsigned char file_download_handle(const unsigned char value[],unsigned long position,unsigned short lengt
             -h)
              {
                  #error "è¯·è‡ªè¡Œå®Œæˆæ–‡ä»¶åŒ…ä¸‹è½½ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  if(length == 0) {
                      //æ–‡ä»¶åŒ…æ•°æ®å‘é€å®Œæˆ
                      
                  }else {
                      //æ–‡ä»¶åŒ…æ•°æ®å¤„ç†
                    
                  }
                  
                  return SUCCESS;
              }
              #endif
1042          
1043          #ifdef MODULE_EXPANDING_SERVICE_ENABLE
              /**
               * @brief  æ‰“å¼€æ¨¡å—æ—¶é—´æœåŠ¡é€šçŸ¥ç»“æœ
               * @param[in] {value} æ•°æ®ç¼“å†²åŒº
               * @param[in] {length} æ•°æ®é•¿åº¦
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void open_module_time_serve_result(const unsigned char value[], unsigned short length)
              {
                  #error "è¯·è‡ªè¡Œå®ç°æ¨¡å—æ—¶é—´æœåŠ¡é€šçŸ¥ç»“æœä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  unsigned char sub_cmd = value[0];
                  
                  switch(sub_cmd) {
                      case 0x01: { //å­å‘½ä»¤  æ‰“å¼€æ¨¡å—æ—¶é—´æœåŠ¡é€šçŸ¥
                          if(0x02 != length) {
                              //æ•°æ®é•¿åº¦é”™è¯¯
                              return;
                          }
                          
                          if(value[1] == 0) {
                              //æœåŠ¡å¼€å¯æˆåŠŸ
                          }else {
                              //æœåŠ¡å¼€å¯å¤±è´¥
                          }
                      }
                      break;
                      
                      case 0x02: {  //å­å‘½ä»¤  æ¨¡å—æ—¶é—´æœåŠ¡é€šçŸ¥
                          if(0x09 != length) {
                              //æ•°æ®é•¿åº¦é”™è¯¯
                              return;
                          }
                          
                          unsigned char time_type = value[1]; //0x00:æ ¼æ—æ—¶é—´  0x01:æœ¬åœ°æ—¶é—´
                          unsigned char time_data[7];
                          
                          my_memcpy(time_data, value + 2, length - 2);
                          /*
                          Data[0]ä¸ºå¹´ä»½, 0x00è¡¨ç¤º2000å¹´
                          Data[1]ä¸ºæœˆä»½ï¼Œä»1å¼€å§‹åˆ°12ç»“æŸ
                          Data[2]ä¸ºæ—¥æœŸï¼Œä»1å¼€å§‹åˆ°31ç»“æŸ
                          Data[3]ä¸ºæ—¶é’Ÿï¼Œä»0å¼€å§‹åˆ°23ç»“æŸ
                          Data[4]ä¸ºåˆ†é’Ÿï¼Œä»0å¼€å§‹åˆ°59ç»“æŸ
C51 COMPILER V9.54   PROTOCOL                                                              02/26/2021 13:53:45 PAGE 19  

                          Data[5]ä¸ºç§’é’Ÿï¼Œä»0å¼€å§‹åˆ°15ç»“æŸ
                          Data[6]ä¸ºæ˜ŸæœŸï¼Œä»1å¼€å§‹åˆ°7ç»“æŸï¼Œ1ä»£è¡¨æ˜ŸæœŸä¸€
                          */
                          
                          //åœ¨æ­¤å¤„æ·»åŠ æ—¶é—´æ•°æ®å¤„ç†ä»£ç ï¼Œtime_typeä¸ºæ—¶é—´ç±»å‹
                          
                          unsigned short send_len = 0;
                          send_len = set_wifi_uart_byte(send_len,sub_cmd);
                          wifi_uart_write_frame(MODULE_EXTEND_FUN_CMD, MCU_TX_VER, send_len);
                      }
                      break;
                      
                      case 0x03: {  //å­å‘½ä»¤  ä¸»åŠ¨è¯·æ±‚å¤©æ°”æœåŠ¡æ•°æ®
                          if(0x02 != length) {
                              //æ•°æ®é•¿åº¦é”™è¯¯
                              return;
                          }
                          
                          if(value[1] == 0) {
                              //æˆåŠŸ
                          }else {
                              //å¤±è´¥
                          }
                      }
                      break;
                      
                      case 0x04: {  //å­å‘½ä»¤  æ‰“å¼€æ¨¡å—é‡ç½®çŠ¶æ€é€šçŸ¥
                          if(0x02 != length) {
                              //æ•°æ®é•¿åº¦é”™è¯¯
                              return;
                          }
                          
                          if(value[1] == 0) {
                              //æˆåŠŸ
                          }else {
                              //å¤±è´¥
                          }
                      }
                      break;
                      
                      case 0x05: {  //å­å‘½ä»¤  æ¨¡å—é‡ç½®çŠ¶æ€é€šçŸ¥
                          if(0x02 != length) {
                              //æ•°æ®é•¿åº¦é”™è¯¯
                              return;
                          }
                          
                          switch(value[1]) {
                              case 0x00:
                                  //æ¨¡å—æœ¬åœ°é‡ç½®
                                  
                              break;
                              case 0x01:
                                  //APPè¿œç¨‹é‡ç½®
                                  
                              break;
                              case 0x02:
                                  //APPæ¢å¤å‡ºå‚é‡ç½®
                                  
                              break;
                              default:break;
                          }
                          
C51 COMPILER V9.54   PROTOCOL                                                              02/26/2021 13:53:45 PAGE 20  

                          unsigned short send_len = 0;
                          send_len = set_wifi_uart_byte(send_len, sub_cmd);
                          wifi_uart_write_frame(MODULE_EXTEND_FUN_CMD, MCU_TX_VER, send_len);
                      }
                      break;
                      
                      default:break;
                  }
              }
              #endif
1159          
1160          #ifdef BLE_RELATED_FUNCTION_ENABLE
              /**
               * @brief  è“ç‰™åŠŸèƒ½æ€§æµ‹è¯•ç»“æœ
               * @param[in] {value} æ•°æ®ç¼“å†²åŒº
               * @param[in] {length} æ•°æ®é•¿åº¦
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void BLE_test_result(const unsigned char value[], unsigned short length)
              {
                  #error "è¯·è‡ªè¡Œå®ç°è“ç‰™åŠŸèƒ½æ€§æµ‹è¯•ç»“æœä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  unsigned char sub_cmd = value[0];
                  
                  if(0x03 != length) {
                      //æ•°æ®é•¿åº¦é”™è¯¯
                      return;
                  }
                  
                  if(0x01 != sub_cmd) {
                      //å­å‘½ä»¤é”™è¯¯
                      return;
                  }
                  
                  unsigned char result = value[1];
                  unsigned char rssi = value[2];
                      
                  if(result == 0) {
                      //æµ‹è¯•å¤±è´¥
                      if(rssi == 0x00) {
                          //æœªæ‰«æåˆ°åç§°ä¸º ty_mdevè“ç‰™ä¿¡æ ‡,è¯·æ£€æŸ¥
                      }else if(rssi == 0x01) {
                          //æ¨¡å—æœªæˆæƒ
                      }
                  }else if(result == 0x01) {
                      //æµ‹è¯•æˆåŠŸ
                      //rssiä¸ºä¿¡å·å¼ºåº¦(0-100, 0ä¿¡å·æœ€å·®ï¼Œ100ä¿¡å·æœ€å¼º)
                  }
              }
              #endif
1199          
1200          #ifdef VOICE_MODULE_PROTOCOL_ENABLE
              /**
               * @brief  è·å–è¯­éŸ³çŠ¶æ€ç ç»“æœ
               * @param[in] {result} è¯­éŸ³çŠ¶æ€ç 
               * @ref       0x00: ç©ºé—²
               * @ref       0x01: micé™éŸ³çŠ¶æ€
               * @ref       0x02: å”¤é†’
               * @ref       0x03: æ­£åœ¨å½•éŸ³
               * @ref       0x04: æ­£åœ¨è¯†åˆ«
               * @ref       0x05: è¯†åˆ«æˆåŠŸ
               * @ref       0x06: è¯†åˆ«å¤±è´¥
C51 COMPILER V9.54   PROTOCOL                                                              02/26/2021 13:53:45 PAGE 21  

               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void get_voice_state_result(unsigned char result)
              {
                  #error "è¯·è‡ªè¡Œå®ç°è·å–è¯­éŸ³çŠ¶æ€ç ç»“æœå¤„ç†ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  switch(result) {
                      case 0:
                          //ç©ºé—²
                      break;
                  
                      case 1:
                          //micé™éŸ³çŠ¶æ€
                      break;
                      
                      case 2:
                          //å”¤é†’
                      break;
                      
                      case 3:
                          //æ­£åœ¨å½•éŸ³
                      break;
                      
                      case 4:
                          //æ­£åœ¨è¯†åˆ«
                      break;
                  
                      case 5:
                          //è¯†åˆ«æˆåŠŸ
                      break;
                      
                      case 6:
                          //è¯†åˆ«å¤±è´¥
                      break;
                      
                    default:break;
                  }
              }
              
              /**
               * @brief  MICé™éŸ³è®¾ç½®ç»“æœ
               * @param[in] {result} è¯­éŸ³çŠ¶æ€ç 
               * @ref       0x00: mic å¼€å¯
               * @ref       0x01: mic é™éŸ³
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void set_voice_MIC_silence_result(unsigned char result)
              {
                  #error "è¯·è‡ªè¡Œå®ç°MICé™éŸ³è®¾ç½®å¤„ç†ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  if(result == 0) {
                      //mic å¼€å¯
                  }else {
                      //mic é™éŸ³
                  }
              }
              
              /**
               * @brief  speakeréŸ³é‡è®¾ç½®ç»“æœ
               * @param[in] {result} éŸ³é‡å€¼
               * @ref       0~10: éŸ³é‡èŒƒå›´
               * @return Null
C51 COMPILER V9.54   PROTOCOL                                                              02/26/2021 13:53:45 PAGE 22  

               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void set_speaker_voice_result(unsigned char result)
              {
                  #error "è¯·è‡ªè¡Œå®ç°speakeréŸ³é‡è®¾ç½®ç»“æœå¤„ç†ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  
              }
              
              /**
               * @brief  éŸ³é¢‘äº§æµ‹ç»“æœ
               * @param[in] {result} éŸ³é¢‘äº§æµ‹çŠ¶æ€
               * @ref       0x00: å…³é—­éŸ³é¢‘äº§æµ‹
               * @ref       0x01: mic1éŸ³é¢‘ç¯è·¯æµ‹è¯•
               * @ref       0x02: mic2éŸ³é¢‘ç¯è·¯æµ‹è¯•
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void voice_test_result(unsigned char result)
              {
                  #error "è¯·è‡ªè¡Œå®ç°éŸ³é¢‘äº§æµ‹ç»“æœå¤„ç†ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  if(result == 0x00) {
                      //å…³é—­éŸ³é¢‘äº§æµ‹
                  }else if(result == 0x01) {
                      //mic1éŸ³é¢‘ç¯è·¯æµ‹è¯•
                  }else if(result == 0x02) {
                      //mic2éŸ³é¢‘ç¯è·¯æµ‹è¯•
                  }
              }
              
              /**
               * @brief  å”¤é†’äº§æµ‹ç»“æœ
               * @param[in] {result} å”¤é†’è¿”å›å€¼
               * @ref       0x00: å”¤é†’æˆåŠŸ
               * @ref       0x01: å”¤é†’å¤±è´¥(10sè¶…æ—¶å¤±è´¥)
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void voice_awaken_test_result(unsigned char result)
              {
                  #error "è¯·è‡ªè¡Œå®ç°å”¤é†’äº§æµ‹ç»“æœå¤„ç†ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  if(result == 0x00) {
                      //å”¤é†’æˆåŠŸ
                  }else if(result == 0x01) {
                      //å”¤é†’å¤±è´¥
                  }
              }
              
              /**
               * @brief  è¯­éŸ³æ¨¡ç»„æ‰©å±•åŠŸèƒ½
               * @param[in] {value} æ•°æ®ç¼“å†²åŒº
               * @param[in] {length} æ•°æ®é•¿åº¦
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void voice_module_extend_fun(const unsigned char value[], unsigned short length)
              {
                  unsigned char sub_cmd = value[0];
                  unsigned char play;
                  unsigned char bt_play;
                  unsigned short send_len = 0;
                
                  switch(sub_cmd) {
C51 COMPILER V9.54   PROTOCOL                                                              02/26/2021 13:53:45 PAGE 23  

                      case 0x00: { //å­å‘½ä»¤  MCUåŠŸèƒ½è®¾ç½®
                          if(0x02 != length) {
                              //æ•°æ®é•¿åº¦é”™è¯¯
                              return;
                          }
                          
                          if(value[1] == 0) {
                              //æˆåŠŸ
                          }else {
                              //å¤±è´¥
                          }
                      }
                      break;
                      
                      case 0x01: {  //å­å‘½ä»¤  çŠ¶æ€é€šçŸ¥
                          if(0x02 > length) {
                              //æ•°æ®é•¿åº¦é”™è¯¯
                              return;
                          }
                          
                          unsigned char play = 0xff;
                          unsigned char bt_play = 0xff;
                          
                          const char *str_buff = (const char *)&value[1];
                          const char *str_result = NULL;
                          
                          str_result = strstr(str_buff,"play") + my_strlen("play") + 2;
                          if(NULL == str_result) {
                              //æ•°æ®é”™è¯¯
                              goto ERR_EXTI;
                          }
                          
                          if(0 == memcmp(str_result, "true", my_strlen("true"))) {
                              play = 1;
                          }else if(0 == memcmp(str_result, "false", my_strlen("false"))) {
                              play = 0;
                          }else {
                              //æ•°æ®é”™è¯¯
                              goto ERR_EXTI;
                          }
                          
                          str_result = strstr(str_buff,"bt_play") + my_strlen("bt_play") + 2;
                          if(NULL == str_result) {
                              //æ•°æ®é”™è¯¯
                              goto ERR_EXTI;
                          }
                          
                          if(0 == memcmp(str_result, "true", my_strlen("true"))) {
                              bt_play = 1;
                          }else if(0 == memcmp(str_result, "false", my_strlen("false"))) {
                              bt_play = 0;
                          }else {
                              //æ•°æ®é”™è¯¯
                              goto ERR_EXTI;
                          }
                          
                          #error "è¯·è‡ªè¡Œå®ç°è¯­éŸ³æ¨¡ç»„çŠ¶æ€é€šçŸ¥å¤„ç†ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                          //MCUè®¾ç½®æš‚ä»…æ”¯æŒâ€æ’­æ”¾/æš‚åœâ€ â€è“ç‰™å¼€å…³â€
                          //play    æ’­æ”¾/æš‚åœåŠŸèƒ½  1(æ’­æ”¾) / 0(æš‚åœ)
                          //bt_play è“ç‰™å¼€å…³åŠŸèƒ½   1(å¼€)   / 0(å…³)
                          
                          
C51 COMPILER V9.54   PROTOCOL                                                              02/26/2021 13:53:45 PAGE 24  

                          
                          send_len = 0;
                          send_len = set_wifi_uart_byte(send_len, sub_cmd);
                          send_len = set_wifi_uart_byte(send_len, 0x00);
                          wifi_uart_write_frame(MODULE_EXTEND_FUN_CMD, MCU_TX_VER, send_len);
                      }
                      break;
              
                      default:break;
                  }
                  
                  return;
              
              ERR_EXTI:
                  send_len = 0;
                  send_len = set_wifi_uart_byte(send_len, sub_cmd);
                  send_len = set_wifi_uart_byte(send_len, 0x01);
                  wifi_uart_write_frame(MODULE_EXTEND_FUN_CMD, MCU_TX_VER, send_len);
                  return;
              }
              #endif
1418          
1419          
1420          
1421          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1014    ----
   CONSTANT SIZE    =      9    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =     24      36
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
